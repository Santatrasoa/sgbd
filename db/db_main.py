import os
import shutil
import json
from pathlib import Path
from typing import Dict, List, Any, Optional
from .user_manager import UserManager
from .permission_manager import PermissionManager


class Db:
    """Classe principale pour la gestion de base de donn√©es"""
    
    def __init__(self, db_path: str = ".database"):
        self.dbName = ""
        self.dbPath = db_path
        self.userManager = UserManager(self.dbPath)
        self.permManager = PermissionManager(self.dbPath)
        self.current_user = {"username": "root", "role": "admin"}
        
        # Cr√©er le dossier de base de donn√©es s'il n'existe pas
        Path(self.dbPath).mkdir(exist_ok=True)

    # -----------------------------
    # DATABASE
    # -----------------------------
    def create_DB(self, dbName: str) -> bool:
        """
        Cr√©e une nouvelle base de donn√©es
        
        Args:
            dbName: Nom de la base de donn√©es
            
        Returns:
            bool: True si cr√©√©e avec succ√®s, False sinon
        """
        if not dbName or not dbName.strip():
            print("‚ùå Le nom de la base de donn√©es ne peut pas √™tre vide")
            return False
        
        path = Path(f"{self.dbPath}/{dbName}")
        
        if path.exists():
            print(f"‚ùå La base de donn√©es '{dbName}' existe d√©j√†")
            return False
        
        try:
            path.mkdir(parents=True, exist_ok=False)
            
            # D√©finir le cr√©ateur comme propri√©taire avec tous les droits
            username = self.current_user["username"]
            self.permManager.set_owner(dbName, username)
            self.permManager.grant(
                dbName, "*", username, "ALL",
                caller_username=username,
                caller_role=self.current_user.get("role")
            )
            
            print(f"‚úì Base de donn√©es '{dbName}' cr√©√©e avec succ√®s")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la cr√©ation de la base de donn√©es: {e}")
            return False

    def list_database(self, path: str) -> List[str]:
        """
        Liste toutes les bases de donn√©es disponibles
        
        Args:
            path: Chemin du r√©pertoire contenant les bases de donn√©es
            
        Returns:
            List[str]: Liste des noms de bases de donn√©es
        """
        directory = Path(path)
        
        if not directory.exists():
            return []
        
        return [
            item.name for item in directory.iterdir()
            if item.is_dir() and not item.name.startswith(".")
        ]

    def drop_database(self, databaseName: str) -> bool:
        """
        Supprime une base de donn√©es
        
        Args:
            databaseName: Nom de la base de donn√©es √† supprimer
            
        Returns:
            bool: True si supprim√©e, False sinon
        """
        if not databaseName or not databaseName.strip():
            print("‚ùå Le nom de la base de donn√©es ne peut pas √™tre vide")
            return False
        
        path = Path(f"{self.dbPath}/{databaseName}")
        
        if not path.exists():
            print(f"‚ùå La base de donn√©es '{databaseName}' n'existe pas")
            return False
        
        if not path.is_dir():
            print(f"‚ùå '{databaseName}' n'est pas une base de donn√©es valide")
            return False
        
        try:
            shutil.rmtree(path)
            
            # Nettoyer les permissions associ√©es
            self.permManager.cleanup_database_permissions(databaseName)
            
            print(f"‚úì Base de donn√©es '{databaseName}' supprim√©e avec succ√®s")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la suppression: {e}")
            return False

    def show_databases(self) -> None:
        """Affiche toutes les bases de donn√©es disponibles"""
        allDirs = self.list_database(self.dbPath)
        
        if not allDirs:
            print("üìÇ Aucune base de donn√©es trouv√©e")
            return
        
        # Calculer la largeur pour l'affichage
        max_len = max([len(d) for d in allDirs] + [15])
        separator = "‚Äî" * (max_len + 4)
        
        print(separator)
        print(f"{'BASES DE DONN√âES':^{max_len + 4}}")
        print(separator)
        
        for db_name in sorted(allDirs):
            # V√©rifier si l'utilisateur est propri√©taire
            is_owner = self.permManager.get_owner(db_name)
            owner_mark = " üëë" if is_owner else ""
            print(f" {db_name:<{max_len}}{owner_mark}")
        
        print(separator)
        print(f"Total: {len(allDirs)} base{'s' if len(allDirs) > 1 else ''} de donn√©es")

    # -----------------------------
    # TABLES
    # -----------------------------
    def list_table(self, path: str) -> List[str]:
        """
        Liste toutes les tables dans une base de donn√©es
        
        Args:
            path: Chemin du r√©pertoire de la base de donn√©es
            
        Returns:
            List[str]: Liste des noms de fichiers de tables
        """
        directory = Path(path)
        
        if not directory.exists():
            return []
        
        return [
            item.name for item in directory.iterdir()
            if item.is_file() and item.suffix == '.json' and not item.name.startswith(".")
        ]

    def create_Table(self, dbName: str, name: str, attribute: Dict[str, Any]) -> bool:
        """
        Cr√©e une nouvelle table
        
        Args:
            dbName: Nom de la base de donn√©es
            name: Nom de la table
            attribute: D√©finition de la table (caract√©ristiques, contraintes, donn√©es)
            
        Returns:
            bool: True si cr√©√©e avec succ√®s, False sinon
        """
        if not name or not name.strip():
            print("‚ùå Le nom de la table ne peut pas √™tre vide")
            return False
        
        path = Path(f"{self.dbPath}/{dbName}/{name}.json")
        
        if path.exists():
            print(f"‚ùå La table '{name}' existe d√©j√†")
            return False
        
        try:
            # Valider la structure de l'attribut
            if "caracteristique" not in attribute:
                print("‚ùå La d√©finition de la table doit contenir 'caracteristique'")
                return False
            
            # Initialiser les donn√©es si absentes
            if "data" not in attribute:
                attribute["data"] = []
            
            # Sauvegarder la table
            with open(path, "w", encoding="utf-8") as f:
                json.dump(attribute, f, indent=2, ensure_ascii=False)
            
            # Accorder tous les droits au cr√©ateur
            username = self.current_user["username"]
            self.permManager.grant(
                dbName, name, username, "ALL",
                caller_username=username,
                caller_role=self.current_user.get("role")
            )
            
            print(f"‚úì Table '{name}' cr√©√©e avec succ√®s")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la cr√©ation de la table: {e}")
            # Nettoyer en cas d'erreur
            if path.exists():
                path.unlink()
            return False

    def drop_table(self, dbName: str, tableName: str) -> bool:
        """
        Supprime une table
        
        Args:
            dbName: Nom de la base de donn√©es
            tableName: Nom de la table √† supprimer
            
        Returns:
            bool: True si supprim√©e, False sinon
        """
        if not tableName or not tableName.strip():
            print("‚ùå Le nom de la table ne peut pas √™tre vide")
            return False
        
        path = Path(f"{self.dbPath}/{dbName}/{tableName}.json")
        
        if not path.exists():
            print(f"‚ùå La table '{tableName}' n'existe pas")
            return False
        
        try:
            path.unlink()
            
            # Nettoyer les permissions de la table
            self.permManager.cleanup_table_permissions(dbName, tableName)
            
            print(f"‚úì Table '{tableName}' supprim√©e avec succ√®s")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la suppression: {e}")
            return False

    def analyse_data(self, path: str, data: List[str]) -> bool:
        """
        Ajoute des donn√©es dans une table
        
        Args:
            path: Chemin vers le fichier de la table
            data: Liste des valeurs √† ins√©rer (format: col=value)
            
        Returns:
            bool: True si ajout√©es avec succ√®s, False sinon
        """
        if not os.path.exists(path):
            print("‚ùå La table n'existe pas")
            return False
        
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = json.load(f)
            
            caracteristiques = content.get("caracteristique", {})
            constraints = content.get("constraint", {})
            
            if not caracteristiques:
                print("‚ùå La table n'a pas de colonnes d√©finies")
                return False
            
            addedData = {}
            
            # Parser les donn√©es
            for i, item in enumerate(data):
                item = item.strip()
                
                if "=" not in item:
                    print(f"‚ùå Erreur de syntaxe dans '{item}' (format attendu: col=value)")
                    return False
                
                try:
                    col, value = item.split("=", 1)
                    col = col.strip()
                    value = value.strip().strip("'").strip('"')
                    
                    # V√©rifier que la colonne existe
                    if col not in caracteristiques:
                        print(f"‚ùå La colonne '{col}' n'existe pas dans la table")
                        print(f"Colonnes disponibles: {', '.join(caracteristiques.keys())}")
                        return False
                    
                    addedData[col] = value
                    
                except ValueError:
                    print(f"‚ùå Erreur lors du parsing de '{item}'")
                    return False
            
            # V√©rifier les colonnes manquantes avec contrainte NOT NULL
            for col, constraint_list in constraints.items():
                if "Not_null" in constraint_list and col not in addedData:
                    print(f"‚ùå La colonne '{col}' ne peut pas √™tre NULL (contrainte NOT NULL)")
                    return False
            
            # V√©rifier les colonnes UNIQUE
            existing_data = content.get("data", [])
            for col, constraint_list in constraints.items():
                if "Unique" in constraint_list and col in addedData:
                    for row in existing_data:
                        if row.get(col) == addedData[col]:
                            print(f"‚ùå Violation de contrainte UNIQUE sur la colonne '{col}'")
                            return False
            
            # Ajouter les donn√©es
            content["data"].append(addedData)
            
            # Sauvegarder
            with open(path, "w", encoding="utf-8") as f:
                json.dump(content, f, indent=2, ensure_ascii=False)
            
            print(f"‚úì Donn√©es ajout√©es avec succ√®s")
            return True
            
        except json.JSONDecodeError:
            print("‚ùå Fichier JSON corrompu")
            return False
        except Exception as e:
            print(f"‚ùå Erreur lors de l'ajout des donn√©es: {e}")
            return False

    def describe_table(self, path: str) -> bool:
        """
        Affiche la description d'une table
        
        Args:
            path: Chemin vers le fichier de la table
            
        Returns:
            bool: True si affich√©e, False sinon
        """
        if not os.path.exists(path):
            print("‚ùå La table n'existe pas")
            return False
        
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = json.load(f)
            
            caracteristiques = content.get("caracteristique", {})
            constraints = content.get("constraint", {})
            data_count = len(content.get("data", []))
            
            if not caracteristiques:
                print("‚ö†Ô∏è La table n'a pas de colonnes d√©finies")
                return True
            
            # Calculer les largeurs
            max_col_len = max([len(k) for k in caracteristiques.keys()] + [10])
            max_type_len = max([len(str(v)) for v in caracteristiques.values()] + [10])
            
            # En-t√™te
            separator = "‚Äî" * (max_col_len + max_type_len + 40)
            table_name = Path(path).stem
            
            print(separator)
            print(f"{'TABLE: ' + table_name.upper():^{len(separator)}}")
            print(separator)
            print(f"{'Colonne':<{max_col_len}} | {'Type':<{max_type_len}} | Contraintes")
            print(separator)
            
            # Afficher chaque colonne
            for col, col_type in caracteristiques.items():
                constraint_list = constraints.get(col, ["Aucune"])
                
                # Formater les contraintes
                if isinstance(constraint_list, list):
                    if "no constraint" in constraint_list:
                        constraint_str = "Aucune"
                    else:
                        constraint_str = ", ".join(constraint_list)
                else:
                    constraint_str = str(constraint_list)
                
                print(f"{col:<{max_col_len}} | {col_type:<{max_type_len}} | {constraint_str}")
            
            print(separator)
            print(f"Total: {len(caracteristiques)} colonne{'s' if len(caracteristiques) > 1 else ''}, {data_count} ligne{'s' if data_count > 1 else ''}")
            print(separator)
            
            return True
            
        except json.JSONDecodeError:
            print("‚ùå Fichier JSON corrompu")
            return False
        except Exception as e:
            print(f"‚ùå Erreur lors de la lecture: {e}")
            return False

    def table_exists(self, dbName: str, tableName: str) -> bool:
        """V√©rifie si une table existe"""
        path = Path(f"{self.dbPath}/{dbName}/{tableName}.json")
        return path.exists()

    def get_table_info(self, dbName: str, tableName: str) -> Optional[Dict[str, Any]]:
        """
        R√©cup√®re les informations d'une table
        
        Returns:
            Dict contenant les informations ou None si erreur
        """
        path = Path(f"{self.dbPath}/{dbName}/{tableName}.json")
        
        if not path.exists():
            return None
        
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return None

    # -----------------------------
    # HELP
    # -----------------------------
    def show_help(self) -> None:
        """Affiche l'aide des commandes disponibles"""
        help_text = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë               COMMANDES DISPONIBLES - MY SGBD                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üì¶ BASES DE DONN√âES
  create_database <nom>              Cr√©er une nouvelle base de donn√©es
  create_db <nom>                    Alias pour create_database
  drop_database <nom>                Supprimer une base de donn√©es
  drop_db <nom>                      Alias pour drop_database
  use_database <nom>                 S√©lectionner une base de donn√©es
  use_db <nom>                       Alias pour use_database
  leave_database                     Quitter la base actuelle
  leave_db                           Alias pour leave_database
  list_database                      Lister toutes les bases
  list_db                            Alias pour list_database

üìã TABLES
  create_table <nom>(col:type[constraint], ...)
                                     Cr√©er une nouvelle table
  add_into_table <table>(col=val, ...)
                                     Ins√©rer des donn√©es
  drop_table <nom>                   Supprimer une table
  list_table                         Lister les tables de la BD active
  describe_table <nom>               D√©crire la structure d'une table

üîç REQU√äTES
  select <colonnes> from <table> [where <condition>]
                                     Interroger les donn√©es
  update <table> set col=val [where <condition>]
                                     Modifier des donn√©es
  delete from <table> [where <condition>]
                                     Supprimer des donn√©es

üë§ UTILISATEURS
  create_user <nom> password=<pwd> [role=<role>]
                                     Cr√©er un utilisateur
  list_user                          Lister les utilisateurs
  drop_user <nom>                    Supprimer un utilisateur
  switch_user_to <nom> password=<pwd>
                                     Changer d'utilisateur

üîê PERMISSIONS
  grant <perm> on <table|*> to <user>
                                     Accorder une permission
  revoke <perm> on <table|*> from <user>
                                     R√©voquer une permission
  show_grants <user>                 Afficher les permissions

‚öôÔ∏è  SYST√àME
  help                               Afficher cette aide
  clear                              Nettoyer l'√©cran
  exit                               Quitter le SGBD

üìñ TYPES DE DONN√âES
  date, year, time, datetime, bool, number, float, string, text, bit

üîí CONTRAINTES
  not_null, unique, primary_key, foreign_key, check, default, auto_increment

üîé OP√âRATEURS WHERE
  =, !=, >, <, >=, <=, LIKE (avec % et _)

üí° EXEMPLES
  create_database ma_db;
  use_db ma_db;
  create_table users(id:number[primary_key], nom:string[not_null]);
  add_into_table users(id=1, nom=Alice);
  select * from users where nom = Alice;
  update users set nom=Bob where id = 1;
  grant SELECT on users to alice;

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
        print(help_text)

    # -----------------------------
    # UTILITAIRES
    # -----------------------------
    def get_statistics(self, dbName: str) -> Dict[str, Any]:
        """
        R√©cup√®re des statistiques sur une base de donn√©es
        
        Returns:
            Dict avec les statistiques
        """
        stats = {
            "database": dbName,
            "tables": 0,
            "total_rows": 0,
            "total_columns": 0
        }
        
        path = Path(f"{self.dbPath}/{dbName}")
        
        if not path.exists():
            return stats
        
        tables = self.list_table(str(path))
        stats["tables"] = len(tables)
        
        for table_file in tables:
            table_path = path / table_file
            try:
                with open(table_path, "r", encoding="utf-8") as f:
                    content = json.load(f)
                    stats["total_rows"] += len(content.get("data", []))
                    stats["total_columns"] += len(content.get("caracteristique", {}))
            except Exception:
                continue
        
        return stats