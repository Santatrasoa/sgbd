import os
import shutil
import json
from pathlib import Path
from typing import Dict, List, Any, Optional
from .user_manager import UserManager
from .permission_manager import PermissionManager


class Db:
    """Classe principale pour la gestion de base de donn√©es"""
    
    def __init__(self, db_path: str = ".database"):
        self.dbName = ""
        self.dbPath = db_path
        self.userManager = UserManager(self.dbPath)
        self.permManager = PermissionManager(self.dbPath)
        self.current_user = {"username": "root", "role": "admin"}
        
        # Cr√©er le dossier de base de donn√©es s'il n'existe pas
        Path(self.dbPath).mkdir(exist_ok=True)

    # -----------------------------
    # DATABASE
    # -----------------------------
    def create_DB(self, dbName: str) -> bool:
        """
        Cr√©e une nouvelle base de donn√©es
        
        Args:
            dbName: Nom de la base de donn√©es
            
        Returns:
            bool: True si cr√©√©e avec succ√®s, False sinon
        """
        if not dbName or not dbName.strip():
            print("‚ùå Database name cannot be empty")
            return False
        
        path = Path(f"{self.dbPath}/{dbName}")
        
        if path.exists():
            print(f"‚ùå Database '{dbName}' already exists")
            return False
        
        try:
            path.mkdir(parents=True, exist_ok=False)
            
            # D√©finir le cr√©ateur comme propri√©taire avec tous les droits
            username = self.current_user["username"]
            self.permManager.set_owner(dbName, username)
            self.permManager.grant(
                dbName, "*", username, "ALL",
                caller_username=username,
                caller_role=self.current_user.get("role")
            )
            
            print(f"‚úì Database '{dbName}' created successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la cr√©ation de la base de donn√©es: {e}")
            return False

    def list_database(self, path: str) -> List[str]:
        """
        Liste toutes les bases de donn√©es disponibles
        
        Args:
            path: Chemin du r√©pertoire contenant les bases de donn√©es
            
        Returns:
            List[str]: Liste des noms de bases de donn√©es
        """
        directory = Path(path)
        
        if not directory.exists():
            return []
        
        return [
            item.name for item in directory.iterdir()
            if item.is_dir() and not item.name.startswith(".")
        ]

    def drop_database(self, databaseName: str) -> bool:
        """
        Supprime une base de donn√©es
        
        Args:
            databaseName: Nom de la base de donn√©es √† supprimer
            
        Returns:
            bool: True si supprim√©e, False sinon
        """
        if not databaseName or not databaseName.strip():
            print("‚ùå Database name cannot be empty")
            return False
        
        path = Path(f"{self.dbPath}/{databaseName}")
        
        if not path.exists():
            print(f"‚ùå Database '{databaseName}' does not exist")
            return False
        
        if not path.is_dir():
            print(f"‚ùå '{databaseName}' is not a valid database")
            return False
        
        try:
            shutil.rmtree(path)
            
            # Cleanup associated permissions
            self.permManager.cleanup_database_permissions(databaseName)
            
            print(f"‚úì Database '{databaseName}' removed successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la suppression: {e}")
            return False

    def show_databases(self) -> None:
        """Affiche toutes les bases de donn√©es disponibles"""
        allDirs = self.list_database(self.dbPath)
        
        if not allDirs:
            print("üìÇ No databases found")
            return
        
        # Calculer la largeur pour l'affichage
        max_len = max([len(d) for d in allDirs] + [15])
        separator = "‚Äî" * (max_len + 4)
        
        print(separator)
        print(f"{'BASES DE DONN√âES':^{max_len + 4}}")
        print(separator)
        
        for db_name in sorted(allDirs):
            # V√©rifier si l'utilisateur est propri√©taire
            is_owner = self.permManager.get_owner(db_name)
            owner_mark = " üëë" if is_owner else ""
            print(f" {db_name:<{max_len}}{owner_mark}")
        
        print(separator)
        print(f"Total: {len(allDirs)} database{'s' if len(allDirs) > 1 else ''}")

    # -----------------------------
    # TABLES
    # -----------------------------
    def list_table(self, path: str) -> List[str]:
        """
        Liste toutes les tables dans une base de donn√©es
        
        Args:
            path: Chemin du r√©pertoire de la base de donn√©es
            
        Returns:
            List[str]: Liste des noms de fichiers de tables
        """
        directory = Path(path)
        
        if not directory.exists():
            return []
        
        return [
            item.name for item in directory.iterdir()
            if item.is_file() and item.suffix == '.json' and not item.name.startswith(".")
        ]

    def create_Table(self, dbName: str, name: str, attribute: Dict[str, Any]) -> bool:
        """
        Cr√©e une nouvelle table
        
        Args:
            dbName: Nom de la base de donn√©es
            name: Nom de la table
            attribute: D√©finition de la table (caract√©ristiques, contraintes, donn√©es)
            
        Returns:
            bool: True si cr√©√©e avec succ√®s, False sinon
        """
        if not name or not name.strip():
            print("‚ùå Table name cannot be empty")
            return False
        
        path = Path(f"{self.dbPath}/{dbName}/{name}.json")
        
        if path.exists():
            print(f"‚ùå Table '{name}' already exists")
            return False
        
        try:
            # Valider la structure de l'attribut
            if "caracteristique" not in attribute:
                print("‚ùå Table definition must include 'caracteristique'")
                return False
            
            # Initialize data if missing
            if "data" not in attribute:
                attribute["data"] = []
            
            # Sauvegarder la table
            with open(path, "w", encoding="utf-8") as f:
                json.dump(attribute, f, indent=2, ensure_ascii=False)
            
            # Grant ALL permissions to the creator
            username = self.current_user["username"]
            self.permManager.grant(
                dbName, name, username, "ALL",
                caller_username=username,
                caller_role=self.current_user.get("role")
            )
            print(f"‚úì Table '{name}' created successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Error creating table: {e}")
            # Nettoyer en cas d'erreur
            if path.exists():
                path.unlink()
            return False

    def drop_table(self, dbName: str, tableName: str) -> bool:
        """
        Supprime une table
        
        Args:
            dbName: Nom de la base de donn√©es
            tableName: Nom de la table √† supprimer
            
        Returns:
            bool: True si supprim√©e, False sinon
        """
        if not tableName or not tableName.strip():
            print("‚ùå Table name cannot be empty")
            return False
        
        path = Path(f"{self.dbPath}/{dbName}/{tableName}.json")
        
        if not path.exists():
            print(f"‚ùå Table '{tableName}' does not exist")
            return False
        
        try:
            path.unlink()
            
            # Cleanup table permissions
            self.permManager.cleanup_table_permissions(dbName, tableName)
            
            print(f"‚úì Table '{tableName}' removed successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la suppression: {e}")
            return False

    def analyse_data(self, path: str, data: List[str]) -> bool:
        """
        Ajoute des donn√©es dans une table
        
        Args:
            path: Chemin vers le fichier de la table
            data: Liste des valeurs √† ins√©rer (format: col=value)
            
        Returns:
            bool: True si ajout√©es avec succ√®s, False sinon
        """
        if not os.path.exists(path):
            print("‚ùå Table does not exist")
            return False
        
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = json.load(f)
            
            caracteristiques = content.get("caracteristique", {})
            # Normalize constraint tokens to lowercase for robust comparisons
            raw_constraints = content.get("constraint", {})
            constraints = {col: [c.lower() for c in (vals if isinstance(vals, list) else [vals])] for col, vals in raw_constraints.items()}
            
            if not caracteristiques:
                print("‚ùå Table has no defined columns")
                return False
            
            addedData = {}
            
            # Parser les donn√©es
            for i, item in enumerate(data):
                item = item.strip()
                
                if "=" not in item:
                    print(f"‚ùå Erreur de syntaxe dans '{item}' (format attendu: col=value)")
                    return False
                
                try:
                    col, value = item.split("=", 1)
                    col = col.strip()
                    value = value.strip().strip("'").strip('"')
                    
                    # V√©rifier que la colonne existe
                    if col not in caracteristiques:
                        print(f"‚ùå La colonne '{col}' n'existe pas dans la table")
                        print(f"Colonnes disponibles: {', '.join(caracteristiques.keys())}")
                        return False
                    
                    addedData[col] = value
                    
                except ValueError:
                    print(f"‚ùå Erreur lors du parsing de '{item}'")
                    return False
            
            # Check NOT NULL constraints (case-insensitive)
            for col, constraint_list in constraints.items():
                if 'not_null' in constraint_list and col not in addedData:
                    print(f"‚ùå Column '{col}' cannot be NULL (NOT NULL constraint)")
                    return False
            
            # Check UNIQUE constraints
            existing_data = content.get("data", [])
            for col, constraint_list in constraints.items():
                if 'unique' in constraint_list and col in addedData:
                    for row in existing_data:
                        if row.get(col) == addedData[col]:
                            print(f"‚ùå UNIQUE constraint violation on column '{col}'")
                            return False
            
            # Append the new row
            content["data"].append(addedData)
            
            # Sauvegarder
            with open(path, "w", encoding="utf-8") as f:
                json.dump(content, f, indent=2, ensure_ascii=False)
            
            print(f"‚úì Data added successfully")
            return True
            
        except json.JSONDecodeError:
            print("‚ùå Corrupted JSON file")
            return False
        except Exception as e:
            print(f"‚ùå Error inserting data: {e}")
            return False

    def describe_table(self, path: str) -> bool:
        """
        Affiche la description d'une table
        
        Args:
            path: Chemin vers le fichier de la table
            
        Returns:
            bool: True si affich√©e, False sinon
        """
        if not os.path.exists(path):
            print("‚ùå Table does not exist")
            return False
        
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = json.load(f)
            
            caracteristiques = content.get("caracteristique", {})
            raw_constraints = content.get("constraint", {})
            constraints = {col: [c.lower() for c in (vals if isinstance(vals, list) else [vals])] for col, vals in raw_constraints.items()}
            data_count = len(content.get("data", []))
            
            if not caracteristiques:
                print("‚ö†Ô∏è Table has no defined columns")
                return True
            
            # Calculer les largeurs
            max_col_len = max([len(k) for k in caracteristiques.keys()] + [10])
            max_type_len = max([len(str(v)) for v in caracteristiques.values()] + [10])
            
            # En-t√™te
            separator = "‚Äî" * (max_col_len + max_type_len + 40)
            table_name = Path(path).stem
            
            print(separator)
            print(f"{'TABLE: ' + table_name.upper():^{len(separator)}}")
            print(separator)
            print(f"{'Column':<{max_col_len}} | {'Type':<{max_type_len}} | Constraints")
            print(separator)
            
            # Afficher chaque colonne
            for col, col_type in caracteristiques.items():
                constraint_list = constraints.get(col, ["no constraint"])
                
                # Format constraints for display (capitalize tokens)
                if isinstance(constraint_list, list):
                    if "no constraint" in constraint_list:
                        constraint_str = "None"
                    else:
                        constraint_str = ", ".join([c.upper() if len(c) <= 6 else c for c in constraint_list])
                else:
                    constraint_str = str(constraint_list)
                
                print(f"{col:<{max_col_len}} | {col_type:<{max_type_len}} | {constraint_str}")
            
            print(separator)
            print(f"Total: {len(caracteristiques)} column{'s' if len(caracteristiques) > 1 else ''}, {data_count} row{'s' if data_count > 1 else ''}")
            print(separator)
            
            return True
            
        except json.JSONDecodeError:
            print("‚ùå Fichier JSON corrompu")
            return False
        except Exception as e:
            print(f"‚ùå Erreur lors de la lecture: {e}")
            return False

    def table_exists(self, dbName: str, tableName: str) -> bool:
        """V√©rifie si une table existe"""
        path = Path(f"{self.dbPath}/{dbName}/{tableName}.json")
        return path.exists()

    def get_table_info(self, dbName: str, tableName: str) -> Optional[Dict[str, Any]]:
        """
        R√©cup√®re les informations d'une table
        
        Returns:
            Dict contenant les informations ou None si erreur
        """
        path = Path(f"{self.dbPath}/{dbName}/{tableName}.json")
        
        if not path.exists():
            return None
        
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return None

    # -----------------------------
    # HELP
    # -----------------------------
    def show_help(self) -> None:
        """Affiche l'aide des commandes disponibles"""
        help_text = """
        ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        ‚ïë               COMMANDES DISPONIBLES - MY SGBD                ‚ïë
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

        üì¶ BASES DE DONN√âES
        create_database <nom>              Cr√©er une nouvelle base de donn√©es
        create_db <nom>                    Alias pour create_database
        drop_database <nom>                Supprimer une base de donn√©es
        drop_db <nom>                      Alias pour drop_database
        use_database <nom>                 S√©lectionner une base de donn√©es
        use_db <nom>                       Alias pour use_database
        leave_database                     Quitter la base actuelle
        leave_db                           Alias pour leave_database
        list_database                      Lister toutes les bases
        list_db                            Alias pour list_database
        stats_db                           Statistiques de la base active
        database_stats                     Alias pour stats_db

        üìã TABLES
        create_table <nom>(col:type[constraint], ...)
                                            Cr√©er une nouvelle table
        add_into_table <table>(col=val, ...)
                                            Ins√©rer des donn√©es
        drop_table <nom>                   Supprimer une table
        list_table                         Lister les tables de la BD active
        describe_table <nom>               D√©crire la structure d'une table

        üîç REQU√äTES
        select <cols> from <table> [where <condition>]
                                            Interroger les donn√©es
        update <table> set col=val [where <condition>]
                                            Modifier des donn√©es
        delete from <table> [where <condition>]
                                            Supprimer des donn√©es

        üë§ UTILISATEURS
        create_user <nom> password=<pwd> [role=<role>]
                                            Cr√©er un utilisateur (role: user|admin)
        list_user                          Lister les utilisateurs
        drop_user <nom>                    Supprimer un utilisateur
        switch_user_to <nom> password=<pwd>
                                            Changer d'utilisateur

        üîê PERMISSIONS
        grant <perm> on <table|db.*|*> to <user>
                                            Accorder une permission
        revoke <perm> on <table|db.*|*> from <user>
                                            R√©voquer une permission
        show_grants <user>                 Afficher les permissions d'un user
        show_grants <db> <user>            Afficher les permissions sur une DB

        ‚öôÔ∏è  SYST√àME
        help                               Afficher cette aide
        list_commands                      Alias pour help
        commands                           Alias pour help
        clear                              Nettoyer l'√©cran
        exit                               Quitter le SGBD

        üìñ TYPES DE DONN√âES
        date, year, time, datetime, bool, number, float, string, text, bit

        üîí CONTRAINTES
        not_null, unique, primary_key, foreign_key, check, default, 
        auto_increment

        üîë PERMISSIONS DISPONIBLES
        SELECT, INSERT, UPDATE, DELETE, DROP, ALL, USAGE

        üîé OP√âRATEURS WHERE
        =, !=, >, <, >=, <=, LIKE (avec % et _ comme wildcards)

        üí° EXEMPLES
        # Gestion des bases
        create_database ma_db;
        use_db ma_db;
        stats_db;
        
        # Cr√©ation de table
        create_table users(
            id:number[primary_key,auto_increment],
            nom:string[not_null,unique],
            age:number,
            email:string
        );
        
        # Insertion de donn√©es
        add_into_table users(id=1, nom=Alice, age=25, email=alice@test.com);
        add_into_table users(id=2, nom=Bob, age=30);
        
        # Requ√™tes SELECT
        select * from users;
        select nom, age from users;
        select * from users where age > 25;
        select * from users where nom LIKE %Ali%;
        
        # Mise √† jour
        update users set age=26 where nom=Alice;
        update users set email=bob@test.com where id=2;
        
        # Suppression
        delete from users where age < 18;
        
        # Gestion des utilisateurs
        create_user alice password=secret123 role=user;
        switch_user_to alice password=secret123;
        
        # Gestion des permissions
        grant SELECT on users to alice;
        grant ALL on ma_db.* to bob;
        revoke DELETE on users from alice;
        show_grants alice;

        üìù NOTES
        ‚Ä¢ Toutes les commandes se terminent par un point-virgule (;)
        ‚Ä¢ Les commandes multi-lignes sont support√©es
        ‚Ä¢ Les noms de colonnes/tables : [a-zA-Z_][a-zA-Z0-9_]*
        ‚Ä¢ Les mots de passe sont hash√©s avec SHA-256
        ‚Ä¢ L'utilisateur 'root' est admin par d√©faut
        ‚Ä¢ Les admins ont tous les droits sur toutes les bases

        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        """
        print(help_text)
    # -----------------------------
    # UTILITAIRES
    # -----------------------------
    def get_statistics(self, dbName: str) -> Dict[str, Any]:
        """
        R√©cup√®re des statistiques sur une base de donn√©es
        
        Returns:
            Dict avec les statistiques
        """
        stats = {
            "database": dbName,
            "tables": 0,
            "total_rows": 0,
            "total_columns": 0
        }
        
        path = Path(f"{self.dbPath}/{dbName}")
        
        if not path.exists():
            return stats
        
        tables = self.list_table(str(path))
        stats["tables"] = len(tables)
        
        for table_file in tables:
            table_path = path / table_file
            try:
                with open(table_path, "r", encoding="utf-8") as f:
                    content = json.load(f)
                    stats["total_rows"] += len(content.get("data", []))
                    stats["total_columns"] += len(content.get("caracteristique", {}))
            except Exception:
                continue
        
        return stats